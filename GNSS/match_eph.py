import numpy as np
from typing import Union
from datetime import datetime

class MatchEph:
    def __init__ (self, brdc_arr, epochs_to_process):
        """
        This class matches broadcast ephemeris to the epoch we want 
        to calculate the satellite positions for
        
        brdc_arr: numpy array
            contains broadcast ephemeris data, generated by ReadBRDC
        epochs_to_process: list
            list of datetime objects or unix timestamps we want to calculate satellite positions for
        """
        self.brdc_arr = brdc_arr
        self._configure_epochs(epochs_to_process)

    def _configure_epochs(self, epochs_to_process):
        """sets all epochs to unix timestamps"""
        if not isinstance(epochs_to_process, Union[list, np.ndarray]):
            raise TypeError("epochs_to_process must be a list or numpy array")
        if isinstance(epochs_to_process[0], datetime):
            self.epochs_unix_stamp_arr = np.array([i.timestamp() for i in epochs_to_process])
        elif isinstance(epochs_to_process[0], Union[int, float]):
            self.epochs_unix_stamp_arr = np.array(epochs_to_process)
                          

    def time_match(self):

        brdc_arr = self.brdc_arr
        epochs_unix_stamp_arr = self.epochs_unix_stamp_arr

        PRN_COLUMN = 2

        unique_prns = np.unique(brdc_arr[:,PRN_COLUMN])

        time_match_arr = np.empty((0, brdc_arr.shape[1]), dtype=brdc_arr.dtype)

        for prn in unique_prns:
            prn_mask = brdc_arr[:,PRN_COLUMN] == prn
            brdc_prn_arr = brdc_arr[prn_mask]

            # Calculate the difference between the epoch and the brdc ephemeris
            # Ensure both arrayrs are 2D column vector for proper broadcasting
            differences = np.abs(brdc_prn_arr[:,-1][:, np.newaxis] - epochs_unix_stamp_arr[np.newaxis, :])
            
            #Find the index of the minimum difference for each timestamp
            closest_indices = np.argmin(differences, axis=0)

            # Retrieve the rows with the closest timestamps
            closest_rows = brdc_prn_arr[closest_indices]

            # replace observation time with process epochs
            closest_rows[:,0] = epochs_unix_stamp_arr

            time_match_arr = np.vstack((time_match_arr, closest_rows))

        return time_match_arr
    
    def iode_match(self):
        pass

# Test the class
if __name__ == "__main__":

    from Readers import ReadBRDC
    from pathlib import Path
    from Downloading.downloading_brdc import DownloadBrdc

    day = datetime(2021, 1, 1)
    local_dir = Path(r"F:/test/match_eph_test/")

    local_file_path = DownloadBrdc(day, local_dir).download()
    brdc_data = ReadBRDC(local_file_path).read()